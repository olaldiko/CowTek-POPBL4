/** @file */
#include "main.h"

char msg[40]; 				/**< The output message of the board. */
uint8_t msgLen = 0; 		/**< The current length of the output message. */
fsm_type state = INIT_S; 	/**< The current state of the FSM. */
DS18_DATA ds18;				/**< DS18 sensor output data struct. */
GPS_Pos position;			/**< GPS Receiver output data struct. */
int main(void){
	while (1){
		switch(state){
			case INIT_S: initState(); break;
			case IDLE_S: idleState(); break;
			case CAPTURE_S: captureState(); break;
			case SEND_S: sendState(); break;
			case ERROR_S: errState(); break;
		}
	}
}
/***********************************************//**
* Initialization state of the board. In this state,
* the board will initialize the DS18 sensor, watchdog, 
* sleep api, USART and USART6 and the GPS. Finally it
* will start the Watchdog countdown and put the 
* FSM in the idle state.
**************************************************/
void initState(){
	initWatchDog();
	SL_Init();
	DS18_Init();
	USART3_Init(34800);
	USART6_Init(9600);
	GPS_setBuffer(usart3_buffer, &bufflen3);
	USART_setIRQ(USART3, GPS_getMsg);
	WD_ResetCounter();
	state = IDLE_S;
}

/***********************************************//**
* Idle state of the board. In this state, the board
* will first restart the watchdog counter and then
* put the board into sleep mode for 25 sec. After 
* waking up, it will wait for 5secs to fill the usart
* buffer with fresh gps data, and finally, after 
* restarting the Watchdog, it will put the FSM in
* capture state.
**************************************************/
void idleState(){
	int i;
	WD_ResetCounter();
	disableIRQs();
	SL_sleepForSecs(25);
	WD_ResetCounter();
	enableIRQs();
	for(i = 0; i < 30;i++){
		delay(65000);
	}
	WD_ResetCounter();
	state = CAPTURE_S;
}

/***********************************************//**
* Capture state of the board. Will first read the ds18
* sensor with the interrupts disabled for more accurate
* timing. After  that, it will get the GPS position and
* re-enable interrupts. Will put the FSM in send state.
**************************************************/
void captureState(){
	int i;
	disableIRQs();
	ds18 = DS18_readSensor();
	position = GPS_getLocation();
	enableIRQs();
	state = SEND_S;
}

/***********************************************//**
* Send state of the board. Will prepare the temp, gps
* lat and lon messages, and send them via usart. Will
* put the FSM in idle mode again.
**************************************************/
void sendState(){
	prepareMsg(msg, SEN_TEMPC_ID, ds18.temp);
	USART_transmitString(USART6, (uint8_t *)msg, msgLen);
	prepareMsg(msg, SEN_GPS_LAT_ID, position.lat);
	USART_transmitString(USART6, (uint8_t *)msg, msgLen);
	prepareMsg(msg, SEN_GPS_LON_ID, position.lon);
	USART_transmitString(USART6, (uint8_t *)msg, msgLen);
	state = IDLE_S;
}

/***********************************************//**
* Error state of the board.
**************************************************/
void errState(){
	
}

/***********************************************//**
* Starts the watchdog with the desired settings.
**************************************************/
void initWatchDog(){
	WD_SetPreescaler(7);
	WD_SetDebugMode(1);
	WD_Start();
}

/***********************************************//**
* Enables the IRQs of the two USARTs.
**************************************************/
void enableIRQs(){
	NVIC_EnableIRQ(USART3_IRQn);
	NVIC_EnableIRQ(USART6_IRQn);
}

/***********************************************//**
* Disables the IRQs of the two USARTs.
**************************************************/
void disableIRQs(){
	NVIC_DisableIRQ(USART3_IRQn);
	NVIC_DisableIRQ(USART6_IRQn);
}

/***********************************************//**
* Prepares the message with the correct format to be sent.
* @param msg The pointer where the message will be stored.
* @param sensor The sensor ID.
* @param value The value generated by that sensor.
**************************************************/
void prepareMsg(char *msg, uint8_t sensor, float value){
	msgLen = sprintf(msg, "$%i%%%i%%%f$\n", BOARD_ID, sensor, value);
}