#ifndef TIMERAPI_C
#define TIMERAPI_C

#include "TIMERAPI.h"
#include "stm32f4xx.h"

funtzio_helbidea_t funcIrq;
/**
*Enables the TIM6 timer in the RCC device. 
*/
void aktTimer(void) {
	RCC->APB1ENR |= (1<<4);
}
/**
*Sets the timer. Sets the timer prescaler and the max counter values.
* @param prescaler The division factor of the timer prescaler.
* @param counter The max counter value.
*/
void setTime(uint16_t prescaler, uint16_t counter) {
	TIM6->PSC = prescaler;
	TIM6->ARR = counter;
}
/**
*Gets the current value of the counter register.
* @return The counter value.
*/
uint16_t getCounter(void) {
	return TIM6->CNT;
}
/**
*Sets the max counter value.
* @param counter The max counter value.
*/
void setLimitea(uint16_t counter) {
	TIM6->ARR = counter;
}
/**
*Returns the update flag of the counter. 
*This flag will activate when the counter reaches the max value. After reading it the flag is cleared.
* @return The update flag. 0-No update happened. 1-A update event happened.
*/
uint16_t isUpdate(uint8_t clear) {
	uint16_t update;
	update = TIM6->SR;
	update &= 1;
	if((update == 1) &&(clear == 1)) {
		TIM6->SR = 0x00;
	}
	return update;
}
/**
*Starts the timer.
*/
void startCounter(void) {
	TIM6->CR1 |= 0x01;
}
/**
*Stops the timer.
*/
void stopCounter(void){
	TIM6->CR1 &= ~(0x01);
}
/**
*Enables or disables the update events of the timer.
* @param mode The update mode. 0-No action, 1-Generates an update and restarts the counter.
*/
void setUpdateMode(int mode) {
	switch(mode) {
		case 0:
			TIM6->EGR = 0x00;
		break;
		case 1:
			TIM6->EGR = 0x01;
		break;
	}
}
/**
*Sets the timer to stop or continue counting when a debug interruption happens.
* @param piztua The mode of the timer under debug. 0-The timer continues to operate, 1-The timer is stopped.
*/
void setDebugMode(int piztua) {
	if(piztua == 1) {
		DBGMCU->APB1FZ |= (1<<4);
	} else {
		DBGMCU->APB1FZ &= ~(1<<4);
	}
	
}
/**
*Enables or disables the one pulse mode of the timer.
* @param mode One pulse mode enabled or disabled. 0-The timer restarts itself when reaching the max counter, 1-The timer stops after reaching the max counter value.
*/
void setOnePulse(int mode) {
	if(mode == 1) {
		TIM6->CR1 |= (1<<2);
	} else {
		TIM6->CR1 &= ~(1<<2);
	}	
}
/**
* Enables or disables the generation of a IRQ when a update event happens
* @param mode 1-The timer generates IRQs. 0-The IRQs are disabled. 
*/
void setUpdateIRQ(int mode) {
	if(mode == 1) {
		TIM6->DIER |=0x01;
	} else {
		TIM6->DIER &= ~(0x01);
	}
}
/**
*Sets the enabled sources for a IRQ generation.
* @param mode 0-All sources are enabled, 1-Only a conter overflow or underflow will generate a IRQ.
*/
void setInterruptSource(int mode) {
	if(mode == 1) {
		TIM6->CR1 |= (1<<2);
	} else {
		TIM6->CR1 &= ~(1<<2);
	}
}
/**
*Clears the timer interrupt pending bit.
*
*/
void clearInterrupt(void) {
	TIM6->SR = 0x0;
}
/**
*Handles the IRQ generated by the timer. Runs the user defined function, clears the timer pending bit and clears the NVIC pending bit.
*/
void TIM6_DAC_IRQHandler(void){
	funcIrq();
	clearInterrupt();
	NVIC_ClearPendingIRQ(TIM6_DAC_IRQn);
}
/**
*Sets the function to be executed inside the TIM6_DAC_IRQHandler.
* @param func The pointer to the desired function.
*/
void ezarriIRQFunc(funtzio_helbidea_t func){
	funcIrq = func;
}
/**
*Initializes the timer interrupts with the basic setup.
*/
void initIRQ_TIM6(void){
	setInterruptSource(1);
	setUpdateIRQ(1);
	NVIC_EnableIRQ(TIM6_DAC_IRQn);
	
}

void resetCounter(){
	stopCounter();
	TIM6->CNT = 0;
}

void delay(uint16_t microsec){
	resetCounter();
	setTime(PRESC, microsec);
	startCounter();
	while(!isUpdate(1));
}

#endif

